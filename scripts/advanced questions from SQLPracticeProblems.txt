-- Practice problems from SQL Practice Problems by Sylvia Moestl Vasilik

Advanced Questions

32. We want to send all of our high-value customers a special VIP gift. We're defining high-value customers as those who've made at least 1 order with a total value (not including the discount) equal to $10,000or more. We only want to consider orders made in the year 1996

SELECT c.customer_id, c.company_name, od.order_id, ROUND(SUM(od.unit_price * od.quantity)::numeric, 2) AS TotalOrderAmount
FROM customers c
INNER JOIN orders o ON o.customer_id = c.customer_id
INNER JOIN order_details od ON od.order_id = o.order_id
WHERE DATE_TRUNC('year', o.order_date) = '1998-01-01'
GROUP BY c.customer_id, c.company_name, od.order_id
HAVING ROUND(SUM(od.unit_price * od.quantity)::numeric, 2) > 10000
ORDER BY TotalOrderAmount DESC

33. The manager has changed his mind. Instead of requiring that customers have at least one individual orders totaling $10,000or more, he wants to define high-value customers as those who have orders totaling $15,000 or more in 2016. How would you change the answer to the problem above?

SELECT c.customer_id, c.company_name, ROUND(SUM(od.unit_price * od.quantity)::numeric, 2) AS TotalOrderAmount
FROM customers c
INNER JOIN orders o ON o.customer_id = c.customer_id
INNER JOIN order_details od ON od.order_id = o.order_id
WHERE DATE_TRUNC('year', o.order_date) = '1998-01-01'
GROUP BY c.customer_id, c.company_name
HAVING ROUND(SUM(od.unit_price * od.quantity)::numeric, 2) > 15000
ORDER BY TotalOrderAmount DESC

34. Change the above query to use the discount when calculating high-value customers.Order by the total amount which includes the discount.

SELECT c.customer_id, c.company_name, 
	ROUND(SUM(od.unit_price * od.quantity)::numeric, 2) AS TotalWithoutDiscount,
	ROUND(SUM(od.unit_price * od.quantity * (1-od.discount))::numeric, 2) AS TotalWithDiscount
FROM customers c
INNER JOIN orders o ON o.customer_id = c.customer_id
INNER JOIN order_details od ON od.order_id = o.order_id
WHERE DATE_TRUNC('year', o.order_date) = '1998-01-01'
GROUP BY c.customer_id, c.company_name
HAVING ROUND(SUM(od.unit_price * od.quantity * (1-od.discount))::numeric, 2) > 10000
ORDER BY TotalWithDiscount DESC

35. At the end of the month, salespeople are likely to try much harder to get orders, to meet their month-end quotas. Show all orders madeon the last day of the month. Order by EmployeeID and OrderID

WITH month_ends AS(
	SELECT GENERATE_SERIES(DATE_TRUNC('month',MIN(order_date)), DATE_TRUNC('month',MAX(order_date)), '1 month'::interval) + '1 month'::INTERVAL - '1 day'::INTERVAL AS months
	FROM orders
	)

SELECT o.employee_id, o.order_id, o.order_date
FROM month_ends m
JOIN orders o ON o.order_date = m.months
ORDER BY o.employee_id, o.order_id

36. The Northwind mobile app developers are testing an app that customers will use to show orders. In order to make sure that even the largest orders will show up correctly on the app, they'd like some samples of orders that have lots of individual line items. Show the10 orders with the most line items, in order of total line items.

SELECT order_id, COUNT(*) AS TotalOrderDetails
FROM order_details
GROUP BY order_id
ORDER BY COUNT(*) DESC
LIMIT 10

37. The Northwind mobile app developers would now like to just get a random assortment of orders for beta testing on their app. Show a random set of 2% of all orders.

SELECT CEIL(COUNT(DISTINCT order_id) *0.02)
FROM order_details

SELECT DISTINCT order_id
FROM order_details
LIMIT 17

38. Janet Leverling, one of the salespeople,has come to you with a request. Shethinks that she accidentally double-entered a line item on an order, with a different ProductID, but the same quantity. She remembers that the quantity was 60 or more. Show all the OrderIDs with line items that match this, in order of OrderID

WITH orders_quantities AS (
	SELECT o.order_id, o.product_id, o.quantity
	FROM order_details o
	--INNER JOIN order_details od ON o.order_id = od.order_id
	WHERE quantity >= 60
	GROUP BY o.order_id, o.quantity, o.product_id
	ORDER BY o.order_id, o.quantity
	)

SELECT order_id
FROM orders_quantities o
GROUP BY o.order_id, o.quantity
HAVING COUNT(quantity) >= 2
ORDER BY o.order_id

39. Based on the previous question, we now want to show details of the order, for orders that match the above criteria.

WITH orders_quantities AS (
		SELECT o.order_id, o.product_id, o.quantity
		FROM order_details o
		--INNER JOIN order_details od ON o.order_id = od.order_id
		WHERE quantity >= 60
		GROUP BY o.order_id, o.quantity, o.product_id
		ORDER BY o.order_id, o.quantity
	),
	order_dup AS (
		SELECT order_id
		FROM orders_quantities o
		GROUP BY o.order_id, o.quantity
		HAVING COUNT(quantity) >= 2
		ORDER BY o.order_id
	)
	
SELECT *
FROM order_details
WHERE order_id IN (SELECT * FROM order_dup)
ORDER BY order_id

40. Here's another way of getting the same results as in the previous problem, using a derived table instead of a CTE. However, there's a bug in this SQL. It returns 20 rows instead of 16. Correct the SQL.

WITH order_dup AS (
		SELECT order_id
		FROM order_details
		WHERE quantity >= 60
		GROUP BY order_id, quantity
		HAVING COUNT(*) > 1
		ORDER BY order_id
	)
	
SELECT *
FROM order_details
WHERE order_id IN (SELECT * FROM order_dup)
ORDER BY order_id


41. Some customers arecomplaining about their orders arriving late. Which orders are late?

SELECT
	order_id, order_date, required_date, shipped_date
FROM orders
WHERE shipped_date > required_date
ORDER BY order_id

41. 